{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fswiss\fcharset0 ArialMT;\f2\froman\fcharset0 Times-Bold;
}
{\colortbl;\red255\green255\blue255;\red49\green72\blue177;\red255\green255\blue255;\red26\green26\blue26;
\red38\green38\blue38;\red0\green0\blue0;\red106\green0\blue67;\red109\green109\blue109;\red29\green0\blue255;
}
{\*\expandedcolortbl;;\cssrgb\c24706\c37255\c74902;\cssrgb\c100000\c100000\c100000;\cssrgb\c13333\c13333\c13333;
\cssrgb\c20000\c20000\c20000;\cssrgb\c0\c0\c0;\cssrgb\c49804\c0\c33333;\cssrgb\c50196\c50196\c50196;\cssrgb\c16471\c0\c100000;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
//\'a0---------\'a0TASK 1\'a0---------
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0function which will return given amount of bits with desired shift
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 uint32\'a0GetBitsFromUint32(unit32\'a0inputValue,\'a0uint8\'a0bitOffset,\'a0uint8\'a0bitLength);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //example:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 uint32\'a0res\'a0=\'a0GetBitsFromUint32(0xABCDEF12,\'a04,\'a012);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0result is:\'a0res\'a0=\'a00x00000EF1;
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0---------\'a0TASK2\'a0---------
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //overload function with const\'a0char\'a0*:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 uint32\'a0GetBitsFromUint32(
\f2\b \cf7 const
\f0\b0 \cf5 \'a0
\f2\b \cf8 char
\f0\b0 \cf4 *\'a0inputValue,\'a0uint8\'a0bitOffset,\'a0uint8\'a0bitLength);
\f1\fs26 \

\f0\fs28 uint32\'a0res\'a0=\'a0GetBitsFromStr(\cf9 "0xABCDEF12"\cf4 ,\'a04,\'a012);\'a0\cf2 //\'a0pay attention to quatation!
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0result shall be the same
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0---------\'a0TASK 3\'a0---------
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0Return full vector (32 elements) with bit values
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 std::vector<
\f2\b \cf8 bool
\f0\b0 \cf4 >\'a0GetBitsVector(std::string\'a0inputValue);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0usage:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 std::vector<
\f2\b \cf8 bool
\f0\b0 \cf4 >\'a0res\'a0=\'a0GetBitsVector(149);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0or
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 std::vector<
\f2\b \cf8 bool
\f0\b0 \cf4 >\'a0res\'a0=\'a0GetBitsVector(0x95);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0expected result
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0res\'a0=\'a0[true,\'a0false,\'a0true,\'a0false,\'a0true,\'a0false,\'a0false,\'a0true,\'a0...]
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0---------\'a0TASK 4\'a0---------
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 // Create Tree class which will be able to generate string trees (like folders structure)
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0example of usage:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs28 \cf8 int
\f0\b0 \cf5 \'a0\cf4 main(...)
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 \{
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0root\'a0=\'a0
\f2\b \cf7 new
\f0\b0 \cf5 \'a0\cf4 Tree(\cf9 "tree name"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz1\'a0=\'a0root->AddSub(\cf9 "galaz\'a01"\cf4 );\'a0\cf2 //\'a0this function creates a child Tree object and returns pointer to it
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz2\'a0=\'a0root->AddSub(\cf9 "galaz\'a02"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz3\'a0=\'a0root->AddSub(\cf9 "galaz\'a03"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz1_1\'a0=\'a0galaz1->AddSub(\cf9 "galaz\'a01.1"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz2_1\'a0=\'a0galaz2->AddSub(\cf9 "galaz\'a02.1"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz2_2\'a0=\'a0galaz2->AddSub(\cf9 "galaz\'a02.2"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 Tree*\'a0galaz2_1_2\'a0=\'a0galaz2_1->AddSub(\cf9 "galaz\'a02.1.2"\cf4 );
\f1\fs26 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0after execution
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 root->print(0);\'a0\cf2 //\'a0in parameter pass initial indent for the object
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0Expected result:
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0tree name
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0galaz\'a01
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a0galaz\'a01.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0galaz\'a02
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a0galaz\'a02.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0galaz\'a02.1.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a0galaz\'a02.2
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0galaz\'a03
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0print works recursive, where indent is passed
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 uint32\'a0rootChildrenCnt\'a0=\'a0root->GetSubCount();\'a0\cf2 //\'a0result shall be\'a03
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 uint32\'a0galaz1childrenCount\'a0=\'a0galaz1->GetSubCount();\'a0\cf2 //\'a0result shall be\'a01
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 uint32\'a0countOfAllChildren\'a0=\'a0root->GetAllSubCount();\'a0\cf2 //\'a0result shall be\'a07\'a0(recursive children counting)
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 root->Del(1);\'a0\cf2 //\'a0will remove\'a0galaz_2\'a0with all it's children (recursive), so in a result only\'a0galaz_1\'a0and\'a0galaz_3 will stay
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 uint32\'a0rootChildrenCnt\'a0_v2\'a0=\'a0root->GetSubCount();\'a0\cf2 //\'a0result shall be\'a02
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf4 uint32\'a0countOfAllChildren\'a0_v2\'a0=\'a0root->GetAllSubCount();\'a0\cf2 //\'a0result shall be\'a03\'a0(recursive children counting)
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0
\f2\b \cf7 delete
\f0\b0 \cf4 (root);\'a0\cf2 //\'a0deleting root shall remove all children (recursive) and clean memory
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 \}
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0---------\'a0TASK\'a05\'a0---------
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0Extension of "print" function which will add automatic numbering
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0execution:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 root->print(0,\'a0
\f2\b \cf7 true
\f0\b0 \cf4 );\'a0\cf2 //\'a0deepth= 0,\'a0true\'a0= print numbers
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0We shall get following result (root has no number)
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0tree name
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a01.\'a0galaz\'a01
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a01.1.\'a0galaz\'a01.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a02.\'a0galaz\'a02
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a02.1.\'a0galaz\'a02.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a02.1.1.\'a0galaz\'a02.1.1
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a02.2.\'a0galaz\'a02.2
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0\'a0\'a0\cf2 //\'a0\'a0\'a0\'a03.\'a0galaz\'a03
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0remove second child:
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf4 root->Del(1);
\f1\fs26 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 //\'a0result:
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0tree name
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0\'a0\'a0\'a01.\'a0galaz\'a01
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0\'a0\'a0\'a0\'a0\'a0\'a01.1.\'a0galaz\'a01.1
\f1\fs26 \cf4 \

\f0\fs28 \cf2 //\'a0\'a0\'a0\'a02.\'a0galaz\'a03
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 // ---------------- TASK 6 ---------------
\f1\fs26 \cf4 \

\f0\fs28 \cf2 // Develop function, which will show all elements of vector in reverse order without usage of any loops or libraries.
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf5 \'a0
\f1\fs26 \cf4 \
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 // input vector: \{ a,b,c,d,e,f,g,h,i,j \}
\f1\fs26 \cf4 \

\f0\fs28 \cf2 // output:
\f1\fs26 \cf4 \

\f0\fs28 \cf2 // j,i,h,g,f,e,d,c,b,a}